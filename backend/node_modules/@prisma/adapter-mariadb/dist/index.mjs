// src/mariadb.ts
import { Debug, DriverAdapterError } from "@prisma/driver-adapter-utils";
import * as mariadb from "mariadb";

// package.json
var name = "@prisma/adapter-mariadb";

// src/conversion.ts
import { ColumnTypeEnum } from "@prisma/driver-adapter-utils";
var UNSIGNED_FLAG = 1 << 5;
var BINARY_FLAG = 1 << 7;
function mapColumnType(field) {
  switch (field.type) {
    case "TINY" /* TINY */:
    case "SHORT" /* SHORT */:
    case "INT24" /* INT24 */:
    case "YEAR" /* YEAR */:
      return ColumnTypeEnum.Int32;
    case "INT" /* INT */:
      if (field.flags.valueOf() & UNSIGNED_FLAG) {
        return ColumnTypeEnum.Int64;
      } else {
        return ColumnTypeEnum.Int32;
      }
    case "LONG" /* LONG */:
    case "BIGINT" /* BIGINT */:
      return ColumnTypeEnum.Int64;
    case "FLOAT" /* FLOAT */:
      return ColumnTypeEnum.Float;
    case "DOUBLE" /* DOUBLE */:
      return ColumnTypeEnum.Double;
    case "TIMESTAMP" /* TIMESTAMP */:
    case "TIMESTAMP2" /* TIMESTAMP2 */:
    case "DATETIME" /* DATETIME */:
    case "DATETIME2" /* DATETIME2 */:
      return ColumnTypeEnum.DateTime;
    case "DATE" /* DATE */:
    case "NEWDATE" /* NEWDATE */:
      return ColumnTypeEnum.Date;
    case "TIME" /* TIME */:
      return ColumnTypeEnum.Time;
    case "DECIMAL" /* DECIMAL */:
    case "NEWDECIMAL" /* NEWDECIMAL */:
      return ColumnTypeEnum.Numeric;
    case "VARCHAR" /* VARCHAR */:
    case "VAR_STRING" /* VAR_STRING */:
    case "STRING" /* STRING */:
    case "BLOB" /* BLOB */:
    case "TINY_BLOB" /* TINY_BLOB */:
    case "MEDIUM_BLOB" /* MEDIUM_BLOB */:
    case "LONG_BLOB" /* LONG_BLOB */:
      if (field["dataTypeFormat"] === "json") {
        return ColumnTypeEnum.Json;
      } else if (field.flags.valueOf() & BINARY_FLAG) {
        return ColumnTypeEnum.Bytes;
      } else {
        return ColumnTypeEnum.Text;
      }
    case "ENUM" /* ENUM */:
      return ColumnTypeEnum.Enum;
    case "JSON" /* JSON */:
      return ColumnTypeEnum.Json;
    case "BIT" /* BIT */:
    case "GEOMETRY" /* GEOMETRY */:
      return ColumnTypeEnum.Bytes;
    case "NULL" /* NULL */:
      return ColumnTypeEnum.Int32;
    default:
      throw new Error(`Unsupported column type: ${field.type}`);
  }
}
function mapArg(arg, argType) {
  if (arg === null) {
    return null;
  }
  if (typeof arg === "string" && argType.scalarType === "bigint") {
    return BigInt(arg);
  }
  if (typeof arg === "string" && argType.scalarType === "datetime") {
    arg = new Date(arg);
  }
  if (arg instanceof Date) {
    switch (argType.dbType) {
      case "TIME" /* TIME */:
      case "TIME2" /* TIME2 */:
        return formatTime(arg);
      case "DATE" /* DATE */:
      case "NEWDATE" /* NEWDATE */:
        return formatDate(arg);
      default:
        return formatDateTime(arg);
    }
  }
  if (typeof arg === "string" && argType.scalarType === "bytes") {
    return Buffer.from(arg, "base64");
  }
  if (ArrayBuffer.isView(arg)) {
    return Buffer.from(arg.buffer, arg.byteOffset, arg.byteLength);
  }
  return arg;
}
function mapRow(row, fields) {
  return row.map((value, i) => {
    const type = fields?.[i].type;
    if (value === null) {
      return null;
    }
    switch (type) {
      case "TIMESTAMP" /* TIMESTAMP */:
      case "TIMESTAMP2" /* TIMESTAMP2 */:
      case "DATETIME" /* DATETIME */:
      case "DATETIME2" /* DATETIME2 */:
        return (/* @__PURE__ */ new Date(`${value}Z`)).toISOString().replace(/(\.000)?Z$/, "+00:00");
    }
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  });
}
var typeCast = (field, next) => {
  if (field.type === "GEOMETRY" /* GEOMETRY */) {
    return field.buffer();
  }
  return next();
};
function formatDateTime(date) {
  const pad = (n, z = 2) => String(n).padStart(z, "0");
  const ms = date.getUTCMilliseconds();
  return pad(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate()) + " " + pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + (ms ? "." + String(ms).padStart(3, "0") : "");
}
function formatDate(date) {
  const pad = (n, z = 2) => String(n).padStart(z, "0");
  return pad(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate());
}
function formatTime(date) {
  const pad = (n, z = 2) => String(n).padStart(z, "0");
  const ms = date.getUTCMilliseconds();
  return pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + (ms ? "." + String(ms).padStart(3, "0") : "");
}

// src/errors.ts
function convertDriverError(error) {
  if (isDriverError(error)) {
    return {
      originalCode: error.errno.toString(),
      originalMessage: error.sqlMessage ?? "N/A",
      ...mapDriverError(error)
    };
  }
  throw error;
}
function mapDriverError(error) {
  switch (error.errno) {
    case 1062: {
      const index = error.sqlMessage?.split(" ").pop()?.split("'").at(1)?.split(".").pop();
      return {
        kind: "UniqueConstraintViolation",
        constraint: index !== void 0 ? { index } : void 0
      };
    }
    case 1451:
    case 1452: {
      const field = error.sqlMessage?.split(" ").at(17)?.split("`").at(1);
      return {
        kind: "ForeignKeyConstraintViolation",
        constraint: field !== void 0 ? { fields: [field] } : void 0
      };
    }
    case 1263: {
      const index = error.sqlMessage?.split(" ").pop()?.split("'").at(1);
      return {
        kind: "NullConstraintViolation",
        constraint: index !== void 0 ? { index } : void 0
      };
    }
    case 1264:
      return {
        kind: "ValueOutOfRange",
        cause: error.sqlMessage ?? "N/A"
      };
    case 1364:
    case 1048: {
      const field = error.sqlMessage?.split(" ").at(1)?.split("'").at(1);
      return {
        kind: "NullConstraintViolation",
        constraint: field !== void 0 ? { fields: [field] } : void 0
      };
    }
    case 1049: {
      const db = error.sqlMessage?.split(" ").pop()?.split("'").at(1);
      return {
        kind: "DatabaseDoesNotExist",
        db
      };
    }
    case 1007: {
      const db = error.sqlMessage?.split(" ").at(3)?.split("'").at(1);
      return {
        kind: "DatabaseAlreadyExists",
        db
      };
    }
    case 1044: {
      const db = error.sqlMessage?.split(" ").pop()?.split("'").at(1);
      return {
        kind: "DatabaseAccessDenied",
        db
      };
    }
    case 1045: {
      const user = error.sqlMessage?.split(" ").at(4)?.split("@").at(0)?.split("'").at(1);
      return {
        kind: "AuthenticationFailed",
        user
      };
    }
    case 1146: {
      const table = error.sqlMessage?.split(" ").at(1)?.split("'").at(1)?.split(".").pop();
      return {
        kind: "TableDoesNotExist",
        table
      };
    }
    case 1054: {
      const column = error.sqlMessage?.split(" ").at(2)?.split("'").at(1);
      return {
        kind: "ColumnNotFound",
        column
      };
    }
    case 1406: {
      const column = error.sqlMessage?.split(" ").flatMap((part) => part.split("'")).at(6);
      return {
        kind: "LengthMismatch",
        column
      };
    }
    case 1191:
      return {
        kind: "MissingFullTextSearchIndex"
      };
    case 1213:
      return {
        kind: "TransactionWriteConflict"
      };
    case 1040:
    case 1203:
      return {
        kind: "TooManyConnections",
        cause: error.sqlMessage ?? "N/A"
      };
    default:
      return {
        kind: "mysql",
        code: error.errno,
        message: error.sqlMessage ?? "N/A",
        state: error.sqlState ?? "N/A",
        cause: error.cause?.message ?? void 0
      };
  }
}
function isDriverError(error) {
  return typeof error.errno === "number" && (typeof error.sqlMessage === "string" || error.sqlMessage === null) && (typeof error.sqlState === "string" || error.sqlState === null);
}

// src/mariadb.ts
var debug = Debug("prisma:driver-adapter:mariadb");
var MariaDbQueryable = class {
  constructor(client) {
    this.client = client;
  }
  provider = "mysql";
  adapterName = name;
  async queryRaw(query) {
    const tag = "[js::query_raw]";
    debug(`${tag} %O`, query);
    const result = await this.performIO(query);
    return {
      columnNames: result.meta?.map((field) => field.name()) ?? [],
      columnTypes: result.meta?.map(mapColumnType) ?? [],
      rows: Array.isArray(result) ? result.map((row) => mapRow(row, result.meta)) : [],
      lastInsertId: result.insertId?.toString()
    };
  }
  async executeRaw(query) {
    const tag = "[js::execute_raw]";
    debug(`${tag} %O`, query);
    return (await this.performIO(query)).affectedRows ?? 0;
  }
  async performIO(query) {
    const { sql, args } = query;
    try {
      const req = {
        sql,
        rowsAsArray: true,
        dateStrings: true,
        // Disable automatic conversion of JSON blobs to objects.
        autoJsonMap: false,
        // Return JSON strings as strings, not objects.
        // Available in the driver, but not provided in the typings.
        jsonStrings: true,
        // Disable automatic conversion of BIT(1) to boolean.
        // Available in the driver, but not provided in the typings.
        bitOneIsBoolean: false,
        typeCast
      };
      const values = args.map((arg, i) => mapArg(arg, query.argTypes[i]));
      return await this.client.query(req, values);
    } catch (e) {
      const error = e;
      this.onError(error);
    }
  }
  onError(error) {
    debug("Error in performIO: %O", error);
    throw new DriverAdapterError(convertDriverError(error));
  }
};
var MariaDbTransaction = class extends MariaDbQueryable {
  constructor(conn, options, cleanup) {
    super(conn);
    this.options = options;
    this.cleanup = cleanup;
  }
  async commit() {
    debug(`[js::commit]`);
    this.cleanup?.();
    await this.client.end();
  }
  async rollback() {
    debug(`[js::rollback]`);
    this.cleanup?.();
    await this.client.end();
  }
};
var PrismaMariaDbAdapter = class extends MariaDbQueryable {
  constructor(client, capabilities, options) {
    super(client);
    this.capabilities = capabilities;
    this.options = options;
  }
  executeScript(_script) {
    throw new Error("Not implemented yet");
  }
  getConnectionInfo() {
    return {
      schemaName: this.options?.database,
      supportsRelationJoins: this.capabilities.supportsRelationJoins
    };
  }
  async startTransaction(isolationLevel) {
    const options = {
      usePhantomQuery: false
    };
    const tag = "[js::startTransaction]";
    debug("%s options: %O", tag, options);
    const conn = await this.client.getConnection().catch((error) => this.onError(error));
    const onError = (err) => {
      debug(`Error from connection: ${err.message} %O`, err);
      this.options?.onConnectionError?.(err);
    };
    conn.on("error", onError);
    const cleanup = () => {
      conn.removeListener("error", onError);
    };
    try {
      const tx = new MariaDbTransaction(conn, options, cleanup);
      if (isolationLevel) {
        await tx.executeRaw({
          sql: `SET TRANSACTION ISOLATION LEVEL ${isolationLevel}`,
          args: [],
          argTypes: []
        });
      }
      await tx.executeRaw({ sql: "BEGIN", args: [], argTypes: [] });
      return tx;
    } catch (error) {
      await conn.end();
      cleanup();
      this.onError(error);
    }
  }
  async dispose() {
    await this.client.end();
  }
  underlyingDriver() {
    return this.client;
  }
};
var PrismaMariaDbAdapterFactory = class {
  provider = "mysql";
  adapterName = name;
  #capabilities;
  #config;
  #options;
  constructor(config, options) {
    this.#config = rewriteConnectionString(config);
    this.#options = options;
  }
  async connect() {
    const pool = mariadb.createPool(this.#config);
    if (this.#capabilities === void 0) {
      this.#capabilities = await getCapabilities(pool);
    }
    return new PrismaMariaDbAdapter(pool, this.#capabilities, this.#options);
  }
};
async function getCapabilities(pool) {
  const tag = "[js::getCapabilities]";
  try {
    const rows = await pool.query({
      sql: `SELECT VERSION()`,
      rowsAsArray: true
    });
    const version = rows[0][0];
    debug(`${tag} MySQL version: %s from %o`, version, rows);
    const capabilities = inferCapabilities(version);
    debug(`${tag} Inferred capabilities: %O`, capabilities);
    return capabilities;
  } catch (e) {
    debug(`${tag} Error while checking capabilities: %O`, e);
    return { supportsRelationJoins: false };
  }
}
function inferCapabilities(version) {
  if (typeof version !== "string") {
    return { supportsRelationJoins: false };
  }
  const [versionStr, suffix] = version.split("-");
  const [major, minor, patch] = versionStr.split(".").map((n) => parseInt(n, 10));
  const isMariaDB = suffix?.toLowerCase()?.includes("mariadb") ?? false;
  const supportsRelationJoins = !isMariaDB && (major > 8 || major === 8 && minor >= 0 && patch >= 13);
  return { supportsRelationJoins };
}
function rewriteConnectionString(config) {
  if (typeof config !== "string") {
    return config;
  }
  if (!config.startsWith("mysql://")) {
    return config;
  }
  return config.replace(/^mysql:\/\//, "mariadb://");
}
export {
  PrismaMariaDbAdapterFactory as PrismaMariaDb
};
